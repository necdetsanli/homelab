# ==============================================================================
# HAProxy Reverse Proxy (enterprise-style) for:
#   - *.app.home.arpa  (client-facing apps)
#   - *.mgmt.home.arpa (admin UIs, WireGuard-only)
#   - vault.home.arpa  (Vault API, restricted networks)
#
# Deployed identically on edge-1 (192.168.20.20) and edge-2 (192.168.20.21)
# behind a Keepalived VIP at 192.168.20.22.
#
# Notes:
# - TLS termination on HAProxy :443.
# - Individual per-service PEM bundles under /etc/haproxy/certs/ (NO wildcards).
#   Each service gets its own certificate via Vault PKI (e.g. argocd.mgmt.home.arpa).
#   HAProxy uses SNI via crt-list to present the correct cert per hostname.
# - Backends are a mix of HTTPS and HTTP; keep the scheme as specified per service.
# - Adjust ACL subnets to match your real network segmentation.
# ==============================================================================

global
  log stdout format raw local0 info
  master-worker

  # Basic hardening / hygiene
  daemon
  maxconn 5000

  # Admin socket (local only)
  stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners

  # Frontend TLS policy (client-facing). Keep strict.
  ssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets
  ssl-default-bind-ciphersuites TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256
  ssl-default-bind-ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256
  tune.ssl.default-dh-param 2048

  # Backend TLS policy (HAProxy -> servers)
  ssl-default-server-options ssl-min-ver TLSv1.2
  ssl-default-server-ciphersuites TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256
  ssl-default-server-ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256

defaults
  log global
  mode http

  option httplog
  option dontlognull
  option http-keep-alive
  http-reuse safe
  option forwardfor except 127.0.0.1

  # Reasonable timeouts for web UIs + long polling
  timeout http-request     10s
  timeout connect          5s
  timeout client           2m
  timeout server           2m
  timeout http-keep-alive  30s
  timeout tunnel           1h

  retries 3
  option redispatch
  default-server inter 3s fall 3 rise 2

# ------------------------------------------------------------------------------
# FRONTEND: HTTP (80) -> Redirect to HTTPS
# ------------------------------------------------------------------------------
frontend fe_http_80
  bind :80
  mode http

  http-request set-var(txn.host) req.hdr(host),lower
  http-request set-var(txn.host) var(txn.host),regsub(:[0-9]+$,,)
  http-request set-header X-Request-ID %[unique-id] if !{ req.hdr(X-Request-ID) -m found }
  http-request redirect scheme https code 301

# ------------------------------------------------------------------------------
# FRONTEND: HTTPS (443) - TLS termination + host-based routing
# ------------------------------------------------------------------------------
frontend fe_https_443
  # Load all certificates in the directory (supports multiple domains/zones).
  # NOTE: crt-list should include ALL PEMs you want HAProxy to present (SNI-based).
  bind :443 ssl crt /etc/haproxy/certs/vault.home.arpa.pem crt-list /etc/haproxy/certsync/crt-list.txt alpn h2,http/1.1
  mode http

  # Normalize Host early (lowercase, strip port).
  http-request set-var(txn.host) req.hdr(host),lower
  http-request set-var(txn.host) var(txn.host),regsub(:[0-9]+$,,)

  # Request ID
  http-request set-header X-Request-ID %[unique-id] if !{ req.hdr(X-Request-ID) -m found }

  # Standard forwarded headers
  http-request set-header X-Forwarded-Proto https
  http-request set-header X-Forwarded-Host  %[var(txn.host)]
  http-request set-header X-Forwarded-Port  443
  http-request set-header X-Real-IP         %[src]

  # Optional security headers (safe defaults)
  http-response set-header X-Content-Type-Options "nosniff"
  http-response set-header Referrer-Policy "no-referrer"
  http-response set-header X-Frame-Options "SAMEORIGIN"
  http-response set-header Permissions-Policy "geolocation=(), microphone=(), camera=()"
  http-response del-header Server

  # ----------------------------
  # Source ACLs (adjust to your subnets)
  # ----------------------------
  # WireGuard admin endpoint(s) (tight allow-list is best).
  acl from_wg_admin src 10.66.66.2/32

  # Management VLAN (example)
  acl from_mgmt_vlan src 192.168.50.0/24

  # "Client API / Servers VLAN" (example)
  acl from_client_api_vlan src 192.168.20.0/24

  # Kubernetes pod CIDR — Cilium native routing preserves pod source IPs.
  # Required for in-cluster workloads (e.g. cert-manager) to reach Vault API.
  acl from_k8s_pods src 10.42.0.0/16

  # ----------------------------
  # Hostname ACLs
  # ----------------------------
  # HAProxy self
  acl host_haproxy_stats var(txn.host) -m str haproxy.mgmt.home.arpa

  # APP
  acl host_nextcloud var(txn.host) -m str nextcloud.app.home.arpa

  # MGMT
  acl host_opnsense     var(txn.host) -m str opnsense.mgmt.home.arpa
  acl host_wazuh        var(txn.host) -m str wazuh.mgmt.home.arpa
  acl host_ipa          var(txn.host) -m str ipa.mgmt.home.arpa
  acl host_ipa_cockpit  var(txn.host) -m str ipa-cockpit.mgmt.home.arpa
  acl host_proxmox      var(txn.host) -m str proxmox.mgmt.home.arpa
  acl host_ilo          var(txn.host) -m str ilo.mgmt.home.arpa
  acl host_unifi        var(txn.host) -m str unifi.mgmt.home.arpa
  acl host_argocd       var(txn.host) -m str argocd.mgmt.home.arpa
  acl host_rancher      var(txn.host) -m str rancher.mgmt.home.arpa
  acl host_longhorn     var(txn.host) -m str longhorn.mgmt.home.arpa
  acl host_adguard      var(txn.host) -m str adguard.mgmt.home.arpa
  acl host_truenas      var(txn.host) -m str truenas.mgmt.home.arpa
  acl host_maltrail     var(txn.host) -m str maltrail.mgmt.home.arpa
  acl host_netdata      var(txn.host) -m str netdata.mgmt.home.arpa
  acl host_ntopng       var(txn.host) -m str ntopng.mgmt.home.arpa
  acl host_me30         var(txn.host) -m str me30.mgmt.home.arpa

  # Vault split-brain naming
  # - vault.home.arpa      -> API endpoint (restricted networks)
  # - vault.mgmt.home.arpa -> UI endpoint (WireGuard-only)
  acl host_vault_api var(txn.host) -m str vault.home.arpa
  acl host_vault_ui  var(txn.host) -m str vault.mgmt.home.arpa

  # ----------------------------
  # Access control gates
  # ----------------------------

  # MGMT zone: WireGuard-only
  acl is_mgmt_zone var(txn.host) -m end .mgmt.home.arpa
  http-request deny deny_status 403 if is_mgmt_zone !from_wg_admin

  # Vault UI: WireGuard-only (redundant with mgmt zone, kept explicit)
  http-request deny deny_status 403 if host_vault_ui !from_wg_admin

  # Vault API: allow only specific internal VLANs + K8s pods (adjust as needed)
  http-request deny deny_status 403 if host_vault_api !from_mgmt_vlan !from_client_api_vlan !from_k8s_pods

  # ----------------------------
  # Routing
  # ----------------------------

  # HAProxy stats (WireGuard-only already enforced)
  use_backend be_haproxy_stats if host_haproxy_stats { path -m beg /_haproxy/stats }
  use_backend be_haproxy_ok    if host_haproxy_stats

  # App
  use_backend be_nextcloud if host_nextcloud

  # Vault
  use_backend be_vault if host_vault_api
  use_backend be_vault if host_vault_ui

  # Mgmt backends
  use_backend be_opnsense     if host_opnsense
  use_backend be_wazuh        if host_wazuh
  use_backend be_ipa          if host_ipa
  use_backend be_ipa_cockpit  if host_ipa_cockpit
  use_backend be_proxmox      if host_proxmox
  use_backend be_ilo          if host_ilo
  use_backend be_unifi        if host_unifi
  use_backend be_argocd       if host_argocd
  use_backend be_rancher      if host_rancher
  use_backend be_longhorn     if host_longhorn
  use_backend be_adguard      if host_adguard
  use_backend be_truenas      if host_truenas
  use_backend be_maltrail     if host_maltrail
  use_backend be_netdata      if host_netdata
  use_backend be_ntopng       if host_ntopng
  use_backend be_me30         if host_me30

  default_backend be_blackhole_404

# ------------------------------------------------------------------------------
# BACKENDS: HAProxy self
# ------------------------------------------------------------------------------

backend be_haproxy_stats
  mode http
  stats enable
  stats uri /_haproxy/stats
  stats refresh 10s
  stats show-node
  stats show-legends

backend be_haproxy_ok
  mode http
  http-request return status 200 content-type "text/plain" lf-string "HAProxy OK\n"

# ------------------------------------------------------------------------------
# BACKENDS: App
# ------------------------------------------------------------------------------

backend be_nextcloud
  mode http
  option httpchk GET /
  http-check expect rstatus (2|3)[0-9][0-9]

  # Nextcloud behind its own reverse proxy / container port
  server nextcloud 192.168.20.51:11000 check

# ------------------------------------------------------------------------------
# BACKENDS: VAULT
# ------------------------------------------------------------------------------

backend be_vault
  mode http
  # Route Vault API ONLY to the active (leader) node.
  # /v1/sys/health:
  # - 200 => active
  # - 429 => standby (we intentionally mark it DOWN)
  option httpchk GET /v1/sys/health
  http-check expect status 200

  # Backend is HTTPS on :8200, verify with our internal Root CA.
  # SNI is set to vault.home.arpa so Vault presents the correct cert.
  default-server ssl verify required ca-file /etc/haproxy/ca/home-arpa-root-ca.crt sni str(vault.home.arpa) check

  server vault1 192.168.20.25:8200
  server vault2 192.168.20.26:8200
  server vault3 192.168.20.27:8200

# ------------------------------------------------------------------------------
# BACKENDS: MGMT (mix of HTTPS/HTTP)
# ------------------------------------------------------------------------------
# NOTE (enterprise reality-check):
# Many appliances ship self-signed certs. For strict enterprise posture you would:
#   - issue internal certs for each (via Vault PKI),
#   - install that cert on the device,
#   - then switch "verify none" -> "verify required ca-file <RootCA>".
# For now we keep verify none but DO set SNI + Host header to avoid 400/handshake issues.

backend be_opnsense
  mode http
  option httpchk GET /
  http-check expect rstatus (2|3)[0-9][0-9]
  server opnsense 192.168.50.1:443 ssl verify none sni str(opnsense.mgmt.home.arpa) check

backend be_wazuh
  mode http
  option httpchk GET /
  http-check expect rstatus (2|3)[0-9][0-9]
  server wazuh 192.168.50.4:443 ssl verify none sni str(wazuh.mgmt.home.arpa) check

backend be_ipa
  mode http
  option httpchk GET /
  http-check expect rstatus (2|3)[0-9][0-9]
  server ipa 192.168.50.5:443 ssl verify none sni str(ipa.mgmt.home.arpa) check

backend be_ipa_cockpit
  mode http
  option httpchk GET /
  http-check expect rstatus (2|3)[0-9][0-9]
  server ipa_cockpit 192.168.50.5:9090 ssl verify none sni str(ipa-cockpit.mgmt.home.arpa) check

backend be_proxmox
  mode http
  option httpchk GET /
  http-check expect rstatus (2|3)[0-9][0-9]
  server proxmox 192.168.50.10:8006 ssl verify none sni str(proxmox.mgmt.home.arpa) check

backend be_ilo
  mode http
  option httpchk GET /
  http-check expect rstatus (2|3)[0-9][0-9]
  server ilo 192.168.50.20:443 ssl verify none sni str(ilo.mgmt.home.arpa) check

backend be_unifi
  mode http
  option httpchk GET /
  http-check expect rstatus (2|3)[0-9][0-9]
  server unifi 192.168.20.10:8443 ssl verify none sni str(unifi.mgmt.home.arpa) check

backend be_argocd
  mode http
  option httpchk GET /healthz
  http-check expect status 200
  # ArgoCD server via MetalLB LoadBalancer IP (re-encrypt: HAProxy → TLS → pod)
  server argocd 192.168.20.200:443 ssl verify none sni str(argocd.mgmt.home.arpa) check check-ssl

backend be_rancher
  mode http
  option httpchk GET /
  http-check expect rstatus (2|3)[0-9][0-9]
  server rancher 192.168.20.60:443 ssl verify none sni str(rancher.mgmt.home.arpa) check

backend be_longhorn
  mode http
  # Longhorn UI via Cilium Gateway API (plain HTTP after HAProxy TLS termination)
  server gateway 192.168.20.201:80 check

backend be_adguard
  mode http
  option httpchk GET /
  http-check expect rstatus (2|3)[0-9][0-9]
  server adguard 192.168.20.53:80 check

backend be_truenas
  mode http
  option httpchk GET /
  http-check expect rstatus (2|3)[0-9][0-9]
  server truenas 192.168.20.50:443 ssl verify none sni str(truenas.mgmt.home.arpa) check

backend be_maltrail
  mode http
  option httpchk GET /
  http-check expect rstatus (2|3)[0-9][0-9]
  server maltrail 192.168.50.1:8338 check

backend be_netdata
  mode http
  option httpchk GET /
  http-check expect rstatus (2|3)[0-9][0-9]
  server netdata 192.168.50.1:19999 check

backend be_ntopng
  mode http
  option httpchk GET /
  http-check expect rstatus (2|3)[0-9][0-9]
  server ntopng 192.168.50.1:3443 ssl verify none sni str(ntopng.mgmt.home.arpa) check

backend be_me30
  mode http
  option httpchk GET /
  http-check expect rstatus (2|3)[0-9][0-9]
  server me30 192.168.30.20:80 check

# ------------------------------------------------------------------------------
# Default sink
# ------------------------------------------------------------------------------
backend be_blackhole_404
  mode http
  http-request return status 404 content-type "text/plain" lf-string "Not Found\n"
